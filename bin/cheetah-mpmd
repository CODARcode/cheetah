#!/usr/bin/env python3

# Example using jsrun:
#   cheetah-mpmd jsrun -n1 -r1 -a1 -c1 --cheetah-app ./gray-scott
#   settings-files.json : jsrun -n1 -r1 -a1 -c1 --cheetah-app pdf_calc
#   gs.bp pdf.bp
#
#   Easy solution is to bind each app to a different set of hosts.
#   Provide an option to share nodes and resources.

# Example using srun:
#   How do you express the no. of ranks per node in an srun conf file for MPMD?
#   I guess you dont need to.

#!/usr/bin/env python3

import sys
import os
import subprocess
import logging
import pdb


#----------------------------------------------------------------------------#
class Runner():
    def __init__(self, apps):
        self.runner = None
        self.apps = apps

    def execute(self):
        pass

    def _run(self, run_cmd):
        assert self.runner is not None
        err_msg = "{} failed. Aborting".format(self.runner)
        log.info("Running `{}`".format(" ".join(run_cmd)))
        try:
            pid = subprocess.Popen(run_cmd)
            pid.communicate()
            pid.wait()
            if pid.returncode != 0:
                log.error(err_msg)
                sys.exit(-1)
        except:
            log.error(err_msg)
            sys.exit(-1)
        log.info("DONE")


#----------------------------------------------------------------------------#
class JsrunRunner(Runner):
    def __init__(self, apps):
        Runner.__init__(self, apps)
        self.runner = 'jsrun'
        self._erf = "mpmd-cheetah-jsrun.erf"
        try:
            os.remove(self._erf)
        except:
            pass

    def execute(self):
        self._create_erf()
        run_cmd = ["jsrun","--erf_input={}".format(self._erf)]
        Runner._run(self, run_cmd)
        # os.remove(self._erf)

    def _create_erf(self):
        sub_erfs = []
        for i,a in enumerate(self.apps):
            sub_erfs.append(self._create_erf_dummy(a, i))
        self._create_main_erf_file(sub_erfs)
        self._remove_erf_dummies(sub_erfs)

    def _create_erf_dummy(self, app, index):
        erf_dummy = ".cheetah-mpmd-{}.erf".format(index)
        run_cmd = []
        run_cmd.append(self.runner)
        for arg in app.runner_args:
            run_cmd.append(arg)
        run_cmd.append("--erf_output={}".format(erf_dummy))
        run_cmd.append("true")
        log.debug("Running jsrun to create temporary erf file " \
                  "{}".format(erf_dummy))
        self._run_erf(run_cmd)
        return erf_dummy

    def _create_main_erf_file(self, sub_erfs):
        app_block = self._get_main_erf_app_block(sub_erfs)
        config_block = self._get_main_erf_config_block(sub_erfs[0])
        mapping_block = self._get_main_erf_mapping_block(sub_erfs)
        with open(self._erf, "w") as f:
            f.write(app_block)
            f.write(config_block)
            f.write(mapping_block)

    def _get_main_erf_app_block(self, sub_erfs):
        appid = -1
        app_block = ""
        for app in self.apps:
            appid = appid + 1
            app_block = app_block + "app {}: {}\n".format(appid, app.app)
        return app_block

    def _get_main_erf_config_block(self, sub_erf0):
        config_block = ""
        with open(sub_erf0) as f:
            lines = f.readlines()
        for line in lines:
            if line.startswith("rank:"):
                break
            if not line.startswith("app"):
                config_block = config_block + line
        return config_block

    def _get_main_erf_mapping_block(self, sub_erfs):
        hostid = 0
        mpmd_rankid = 0
        appid = -1
        mapping_block = ""
        subfiles = []
        for erf_out in sub_erfs:
            appid = appid + 1
            hostid = hostid + 1
            lines = []
            with open(erf_out) as f:
                lines = f.readlines()
            for line in lines:
                if line.startswith("rank:"):
                    cpu_mapping = line.split("cpu: ")[1].split(" : app")[0]
                    mapping_block = mapping_block + \
                                    "rank: {}:".format(mpmd_rankid) + \
                                    " {{ host: {};".format(hostid) + \
                                    " cpu: {}".format(cpu_mapping) + \
                                    " : app {}\n".format(appid)
                    mpmd_rankid = mpmd_rankid + 1
        return mapping_block

    def _remove_erf_dummies(self, sub_erfs):
        for f in sub_erfs:
            os.remove(f)


#----------------------------------------------------------------------------#
class SlurmRunner(Runner):
    def __init__(self, apps):
        Runner.__init__(self, apps)
        self.runner = 'srun'
        self.conf_file = "mpmd-cheetah-slurm.conf"

    def execute(self):
        self._create_slurm_conf()
        run_cmd = ['srun', '--multi-prog', '{}'.format(self.conf_file)]
        Runner._run(self, run_cmd)

    def _create_slurm_conf(self):
        log.info("Creating mpmd conf file {}".format(self.conf_file))
        mpmd_rankid = 0
        s = ""
        for app in self.apps:
            nprocs = self._get_app_nprocs(app.runner_args)
            s = s + "{}-{}".format(mpmd_rankid, mpmd_rankid+nprocs-1)
            s = s + "\t{}\n".format(app.app)
            mpmd_rankid = mpmd_rankid + nprocs
        try:
            with open(self.conf_file, "w") as f:
                f.write(s)
        except:
            log.error("Could not create conf file. Aborting")
            sys.exit(-1)
        log.info("Created conf file successfully")

    def _get_app_nprocs(self, runner_args):
        nprocs = 0
        for i,a in enumerate(runner_args):
            if a == '-n':
                nprocs = int(runner_args[i+1])
                break
            elif a.startswith('-n'):
                nprocs = int(a.split('-n')[1])
                break
        assert nprocs > 0
        return nprocs


#----------------------------------------------------------------------------#
class MpiexecRunner(Runner):
    def __init__(self):
        Runner.__init__(apps)
        self.runner = 'mpirun'

    def execute(self):
        pass


#----------------------------------------------------------------------------#
class App:
    def __init__(self, l):
        self.exe = l[0]
        self.args = l[1:]

    def __str__(self):
        return (self.exe + " " + " ".join(self.args))


#----------------------------------------------------------------------------#
class AppCmd:
    """
    An object to hold each application launched in the MPMD command
    """
    def __init__(self, l_argv):
        """
        Attributes:
        l_argv
        """
        self._validate(l_argv)
        self.cmd = l_argv
        self.runner = self._get_runner()
        self.runner_args = self._get_runner_args()
        self.app = self._extract_app()

    def __str__(self):
        str = ""
        str_l_argv = " ".join(self.cmd)

        # str_app_args = " ".join(self.app_args)

        str = str + "App command: {}\n".format(" ".join(self.cmd))
        str = str + "Runner: {}\n".format(self.runner)
        str = str + "Runner args: {}\n".format(" ".join(self.runner_args))
        str = str + "App exe: {}\n".format(self.app.exe)
        str = str + "App arguments: {}\n".format(" ".join(self.app.args))
        return str

    def _validate(self, cmd):
        assert '--cheetah-app' in cmd, \
            "Did not find --cheetah-app in app run command '{}'".format(cmd)

    def _get_runner(self):
        """
        Get the runner (jsrun/srun/mpirun)
        """
        runner = self.cmd[0]
        assert runner in ('jsrun', 'srun', 'mpirun', 'mpiexec'), \
            "App runner must be one of jsrun/srun/mpirun/mpiexec. " \
            "Found {}".format(runner)
        return runner

    def _get_runner_args(self):
        runner_args = []
        for i,e in enumerate(self.cmd[1:]):
            if e == '--cheetah-app':
                runner_args = self.cmd[1:i+1]
        assert len(runner_args) > 0, \
            "No arguments to {} found".format(self.runner)
        return runner_args

    def _extract_app(self):
        app = None
        for i,e in enumerate(self.cmd):
            if '--cheetah-app' in e:
                app = App(self.cmd[i+1:])
        assert app is not None, \
            "Cheetah app command cannot be None '{}'".format(self)
        return app


#----------------------------------------------------------------------------#
def extract_cheetah_apps():
    """
    Extract all app execution commands.
    For example: The following command has two applications
    "cheetah-mpmd jsrun -p1 --cheetah-app echo hello :
    jsrun -p2 --cheetah-app echo hello2"
    """
    apps = []
    start_index = 1
    for i,e in enumerate(sys.argv[1:]):
        if e == ':':
            app_cmd = AppCmd(sys.argv[start_index:i+1])
            apps.append(app_cmd)
            start_index = start_index + i+1
    app_cmd = AppCmd(sys.argv[start_index:])
    apps.append(app_cmd)
    return apps

def verify_same_runner(apps):
    """
    Verify that all apps are launched using the same runner. e.g., you cannot
    have jsrun and srun in an MPMD launch.
    """
    runner = apps[0].runner
    for a in apps:
        assert a.runner == runner, \
            "Apps must have the same runner. Found different runners {} and " \
            "{} ".format(runner, a.runner)


#----------------------------------------------------------------------------#
loglevel = os.environ.get("LOG_LEVEL", "INFO")
logging.basicConfig(format='%(levelname)s: %(message)s',level=loglevel)
log = logging.getLogger("")

runners = {'jsrun':JsrunRunner, 'srun':SlurmRunner, 'mpirun':MpiexecRunner,
           'mpiexec': MpiexecRunner}

apps = extract_cheetah_apps()
verify_same_runner(apps)
# for a in apps:
#    print(a)

runner = runners[apps[0].runner](apps)
runner.execute()

